<!DOCTYPE html>
<head><script>window.CONFIG={"packageName":"@cxl/gbc.sdk","activeVersion":"0.0.1","versions":"../version.json","repository":"https://github.com/giancarlo/gbc","demoScripts":[],"spa":false,"symbols":[{"name":"Position","kind":4,"href":"index--Position.html"},{"name":"Token","kind":4,"href":"index--Token.html"},{"name":"MatchFn","kind":2,"href":"index-api.html#s9"},{"name":"ScanFn","kind":2,"href":"index-api.html#s14"},{"name":"Scanner","kind":2,"href":"index-api.html#s18"},{"name":"BaseNode","kind":2,"href":"index-api.html#s32"},{"name":"NodeMap","kind":2,"href":"index-api.html#s35"},{"name":"OperatorTable","kind":2,"href":"index-api.html#s40"},{"name":"Operator","kind":2,"href":"index-api.html#s45"},{"name":"MapNode","kind":2,"href":"index-api.html#s52"},{"name":"ParentNode","kind":2,"href":"index-api.html#s83"},{"name":"UnaryNode","kind":2,"href":"index-api.html#s87"},{"name":"InfixNode","kind":2,"href":"index-api.html#s91"},{"name":"TernaryNode","kind":2,"href":"index-api.html#s95"},{"name":"MapKind","kind":2,"href":"index-api.html#s100"},{"name":"DistributeToken","kind":2,"href":"index-api.html#s103"},{"name":"MapToToken","kind":2,"href":"index-api.html#s107"},{"name":"TrieNode","kind":2,"href":"index-api.html#s111"},{"name":"matchers","kind":31,"href":"index-api.html#s130"},{"name":"stringEscape","kind":31,"href":"index-api.html#s164"},{"name":"CompilerError","kind":8,"href":"index--CompilerError.html"},{"name":"text","kind":16,"href":"index-api.html#s172"},{"name":"each","kind":16,"href":"index-api.html#s174"},{"name":"line","kind":16,"href":"index-api.html#s183"},{"name":"lineText","kind":16,"href":"index-api.html#s187"},{"name":"formatError","kind":16,"href":"index-api.html#s189"},{"name":"ErrorApi","kind":2,"href":"index-api.html#s193"},{"name":"ErrorApi","kind":16,"href":"index-api.html#s209"},{"name":"SymbolTable","kind":2,"href":"index-api.html#s225"},{"name":"SymbolTable","kind":16,"href":"index-api.html#s255"},{"name":"MakeNodeMap","kind":2,"href":"index-api.html#s288"},{"name":"ParserApi","kind":2,"href":"index-api.html#s292"},{"name":"ParserApi","kind":16,"href":"index-api.html#s394"},{"name":"parserTable","kind":16,"href":"index-api.html#s928"},{"name":"findNodeAtIndex","kind":16,"href":"index-api.html#s1036"},{"name":"createTrie","kind":16,"href":"index-api.html#s1039"},{"name":"ScannerApi","kind":16,"href":"index-api.html#s1042"}]};</script><meta charset="utf-8"><meta name="description" content="Documentation for @cxl/gbc.sdk" /><script type="module" src="3doc.js"></script><title>@cxl/gbc.sdk API Reference</title><style>
doc-ct { gap:8px;margin-bottom:24px;white-space:wrap;font:var(--cxl-font-code);font-size:18px;display:flex;align-items:center; }
c-page { opacity: 0; }
c-page[ready] { opacity: 1; }
#appbar-toolbar {max-width: 1200px; margin: auto; width: 100%}</style></head>
<c-page><doc-appbar></doc-appbar><c-drawer id="navbar">
		<doc-item href="index.html" external>Home</doc-item><c-hr></c-hr>	
		<doc-item href="index-api.html" external><i>Index</i></doc-item><doc-item href="index--CompilerError.html" external><c-avatar size="-1" text="C"></c-avatar>CompilerError</doc-item><doc-item href="index--Position.html" external><c-avatar size="-1" text="I"></c-avatar>Position</doc-item><doc-item href="index--Token.html" external><c-avatar size="-1" text="I"></c-avatar>Token</doc-item>
		</c-drawer><c-body><c-flex gap="8"><c-chip size="-1" color="primary">module</c-chip> </c-flex><c-t font="h3">index.ts</c-t><div style="margin-top:32px"></div><c-t font="h6">Classes
		</c-t><doc-grd><a href="index--CompilerError.html">CompilerError</a></doc-grd><c-t font="h6">Constants
		</c-t><doc-grd><a href="#s130">matchers</a><a href="#s164">stringEscape</a></doc-grd><c-t font="h6">Functions
		</c-t><doc-grd><a href="#s209">ErrorApi</a><a href="#s394">ParserApi</a><a href="#s1042">ScannerApi</a><a href="#s255">SymbolTable</a><a href="#s1039">createTrie</a><a href="#s174">each</a><a href="#s1036">findNodeAtIndex</a><a href="#s189">formatError</a><a href="#s183">line</a><a href="#s187">lineText</a><a href="#s928">parserTable</a><a href="#s172">text</a></doc-grd><c-t font="h6">Interfaces
		</c-t><doc-grd><a href="index--Position.html">Position</a><a href="index--Token.html">Token</a></doc-grd><c-t font="h6">Type Alias
		</c-t><doc-grd><a href="#s32">BaseNode</a><a href="#s103">DistributeToken</a><a href="#s193">ErrorApi</a><a href="#s91">InfixNode</a><a href="#s288">MakeNodeMap</a><a href="#s100">MapKind</a><a href="#s52">MapNode</a><a href="#s107">MapToToken</a><a href="#s9">MatchFn</a><a href="#s35">NodeMap</a><a href="#s45">Operator</a><a href="#s40">OperatorTable</a><a href="#s83">ParentNode</a><a href="#s292">ParserApi</a><a href="#s14">ScanFn</a><a href="#s18">Scanner</a><a href="#s225">SymbolTable</a><a href="#s95">TernaryNode</a><a href="#s111">TrieNode</a><a href="#s87">UnaryNode</a></doc-grd><c-t font="h5">Constants</c-t><doc-card id="s130" src="index.ts#L89"><doc-ct><div>matchers: { <doc-more> alpha: (ch: string) => boolean; digit: (ch: string) => boolean; alnum: (ch: string) => boolean; hexDigit: (ch: string) => boolean; digitUnderscore: (ch: string) => boolean; hexDigitUnderscore: (ch: string) => boolean; binaryDigit: (ch: string) => <div></div>; binaryDigitUnderscore: (ch: string) => <div></div>; ident: (ch: string) => boolean; notIdent: (ch: string) => <div></div>; eol: (ch: string) => <div></div></doc-more> }</div></doc-ct></doc-card><doc-card id="s164" src="index.ts#L103"><doc-ct><div>stringEscape: (n: number, src: string) => boolean</div></doc-ct></doc-card><c-t font="h5">Functions</c-t><doc-card id="s209" src="index.ts#L165"><doc-ct><div>ErrorApi(): { catchAndRecover: &lt;T&gt;(fn: () => T, recover: () => T) => T; errors: CompilerError[]; error: (msg: string, pos: Position) => CompilerError; pushError: (error: CompilerError) => void }</div></doc-ct></doc-card><doc-card id="s394" src="index.ts#L270"><doc-ct><div>ParserApi&lt;Node extends <a href="index--Token.html">Token</a>&lt;string&gt;&gt;(scanner: <a href="index-api.html#s18">Scanner</a>&lt;<a href="#s395">Node</a>&gt;): { <doc-more> current: () => Node; error: (msg: string, pos: Position) => CompilerError; pushError: (error: CompilerError) => void; errors: CompilerError[]; expect: &lt;K extends <a href="#s395">Node</a>["kind"]&gt;(kind: K) => Token&lt;K&gt;; expectNode: &lt;C&gt;(node: C | undefined, msg: string) => NonNullable&lt;C&gt;; expectNodeKind: &lt;N extends <a href="index--Token.html">Token</a>&lt;string&gt;, K extends <a href="#s420">N</a>["kind"]&gt;(node: N | undefined, kind: K, msg: string) => Extract&lt;<a href="#s420">N</a>, { kind: K }&gt;; expectNodeParser: (fn: () => Node | undefined, msg: string) => () => NonNullable&lt;Node&gt;; next: () => Node; node: &lt;K extends string&gt;(kind: K) => Token&lt;K&gt;; optional: &lt;K extends <a href="#s395">Node</a>["kind"]&gt;(kind: K) => Token&lt;K&gt; | undefined; skipWhile: (kind: Node["kind"]) => void; enclosed: &lt;C extends <a href="#s395">Node</a>&gt;(start: Node["kind"], content: () => C, end: Node["kind"]) => C; skipUntil: (condition: () => boolean) => void; parseUntil: &lt;C&gt;(parser: () => C | undefined, condition: () => boolean) => C[]; parseUntilKind: &lt;C&gt;(parser: () => C | undefined, kind: Node["kind"]) => C[]; parseList: &lt;C&gt;(parseFn: () => C | undefined, separator: Node["kind"], isItem: (item: C) => boolean) => C[]; parseListWithEmpty: &lt;C&gt;(parseFn: () => C | undefined, separator: Node["kind"], isItem: (item: C) => boolean) => (C | undefined)[]; start: (src: string) => void; backtrack: (pos: Node) => void; parseWhile: &lt;C&gt;(parser: () => C | undefined) => C[]</doc-more> }</div></doc-ct><c-t font="subtitle2">Parameters</c-t><ul><li><code>scanner: <a href="index-api.html#s18">Scanner</a>&lt;<a href="#s395">Node</a>&gt;</code></li></ul></doc-card><doc-card id="s1042" src="index.ts#L625"><doc-ct><div>ScannerApi({ source }: { source: string }): { <doc-more> createTrieMatcher: &lt;T extends string&gt;(map: readonly T[], end: MatchFn) => (consumed?: number) => MapToToken&lt;T&gt; | undefined; tk: &lt;Kind extends string&gt;(kind: Kind, consume: number) => Token&lt;Kind&gt;; matchWhile: (match: MatchFn, consumed?: number) => number; matchUntil: (match: MatchFn, consumed?: number) => number; matchString: (s: string, matchEnd?: ((ch: string) => boolean) | undefined, consumed?: number) => number; matchEnclosed: (match: MatchFn, escape?: ((index: number, source: string) => void) | undefined, n?: number) => number; matchWhileRegex: (regex: RegExp, consumed?: number) => number; error: (message: string, consumed?: number, start?: number) => CompilerError; skip: (offset?: number) => number; skipWhitespace: () => void; backtrack: (pos: Position) => void; eof: (offset?: number) => boolean; current: (offset?: number) => string</doc-more> }</div></doc-ct><c-t font="subtitle2">Parameters</c-t><ul><li><code>{ source }: { source: string }</code></li></ul></doc-card><doc-card id="s255" src="index.ts#L207"><doc-ct><div>SymbolTable&lt;S&gt;(newScope: () => Record&lt;string | Symbol, <a href="#s256">S</a>&gt; = () => ({})): { <doc-more> globalScope: Record&lt;string | Symbol, S&gt;; stack: Record&lt;string | Symbol, S&gt;[]; push: () => Record&lt;string | Symbol, S&gt;; pop: (expectedScope: Record&lt;string | Symbol, S&gt;) => void; get(id: string | Symbol): NonNullable&lt;S&gt; | undefined; set&lt;T extends <a href="#s256">S</a>&gt;(id: string | Symbol, symbol: T): T; setSymbols(symbols: Record&lt;string, S&gt;): void; withScope&lt;C&gt;(fn: (scope: Record&lt;string | Symbol, S&gt;) => C): C</doc-more> }</div></doc-ct><c-t font="subtitle2">Parameters</c-t><ul><li><code>newScope: () => Record&lt;string | Symbol, <a href="#s256">S</a>&gt; = () => ({})</code></li></ul></doc-card><doc-card id="s1039" src="index.ts#L610"><doc-ct><div>createTrie&lt;T extends string&gt;(...map: <a href="#s1040">T</a>[]): <a href="index-api.html#s111">TrieNode</a></div></doc-ct><p>Builds a trie from the input map and</p><c-t font="subtitle2">Parameters</c-t><ul><li><code>...map: <a href="#s1040">T</a>[]</code></li></ul></doc-card><doc-card id="s174" src="index.ts#L114"><doc-ct><div>each&lt;Node extends <a href="index--Token.html">Token</a>&lt;string&gt;&gt;(scan: <a href="index-api.html#s14">ScanFn</a>&lt;<a href="#s175">Node</a>&gt;): { () => { next(): { done: boolean; value: Node } | { value: Node; done?: undefined } } }</div></doc-ct><c-t font="subtitle2">Parameters</c-t><ul><li><code>scan: <a href="index-api.html#s14">ScanFn</a>&lt;<a href="#s175">Node</a>&gt;</code></li></ul></doc-card><doc-card id="s1036" src="index.ts#L601"><doc-ct><div>findNodeAtIndex(node: <a href="index-api.html#s32">BaseNode</a>, index: number): <a href="index-api.html#s32">BaseNode</a></div></doc-ct><c-t font="subtitle2">Parameters</c-t><ul><li><code>node: <a href="index-api.html#s32">BaseNode</a></code></li><li><code>index: number</code></li></ul></doc-card><doc-card id="s189" src="index.ts#L146"><doc-ct><div>formatError(error: <a href="index--CompilerError.html">CompilerError</a>, options?: { startLine?: number }): string</div></doc-ct><c-t font="subtitle2">Parameters</c-t><ul><li><code>error: <a href="index--CompilerError.html">CompilerError</a></code></li><li><code>options?: { startLine?: number }</code></li></ul></doc-card><doc-card id="s183" src="index.ts#L129"><doc-ct><div>line({ source, start }: <a href="index--Position.html">Position</a>): { start: number; end: number }</div></doc-ct><c-t font="subtitle2">Parameters</c-t><ul><li><code>{ source, start }: <a href="index--Position.html">Position</a></code></li></ul></doc-card><doc-card id="s187" src="index.ts#L141"><doc-ct><div>lineText(node: <a href="index--Position.html">Position</a>): string</div></doc-ct><c-t font="subtitle2">Parameters</c-t><ul><li><code>node: <a href="index--Position.html">Position</a></code></li></ul></doc-card><doc-card id="s928" src="index.ts#L593"><doc-ct><div>parserTable&lt;Map extends <a href="index-api.html#s35">NodeMap</a>, ScannerToken extends <a href="index--Token.html">Token</a>&lt;string&gt;&gt;(tableFn: <a href="#s498">ParserTableFn</a>&lt;<a href="#s929">Map</a>, <a href="#s930">ScannerToken</a>&gt;): (api: { <doc-more> current: () => ScannerToken; error: (msg: string, pos: Position) => CompilerError; pushError: (error: CompilerError) => void; errors: CompilerError[]; expect: &lt;K extends ScannerToken["kind"]&gt;(kind: K) => Token&lt;K&gt;; expectNode: &lt;C&gt;(node: C | undefined, msg: string) => NonNullable&lt;C&gt;; expectNodeKind: &lt;N extends <a href="index--Token.html">Token</a>&lt;string&gt;, K extends N["kind"]&gt;(node: N | undefined, kind: K, msg: string) => Extract&lt;N, { kind: K }&gt;; expectNodeParser: (fn: () => ScannerToken | undefined, msg: string) => () => NonNullable&lt;ScannerToken&gt;; next: () => ScannerToken; node: &lt;K extends string&gt;(kind: K) => Token&lt;K&gt;; optional: &lt;K extends ScannerToken["kind"]&gt;(kind: K) => Token&lt;K&gt; | undefined; skipWhile: (kind: ScannerToken["kind"]) => void; enclosed: &lt;C extends ScannerToken&gt;(start: ScannerToken["kind"], content: () => C, end: ScannerToken["kind"]) => C; skipUntil: (condition: () => boolean) => void; parseUntil: &lt;C&gt;(parser: () => C | undefined, condition: () => boolean) => C[]; parseUntilKind: &lt;C&gt;(parser: () => C | undefined, kind: ScannerToken["kind"]) => C[]; parseList: &lt;C&gt;(parseFn: () => C | undefined, separator: ScannerToken["kind"], isItem: (item: C) => boolean) => C[]; parseListWithEmpty: &lt;C&gt;(parseFn: () => C | undefined, separator: ScannerToken["kind"], isItem: (item: C) => boolean) => (C | undefined)[]; start: (src: string) => void; backtrack: (pos: ScannerToken) => void; parseWhile: &lt;C&gt;(parser: () => C | undefined) => C[]</doc-more> }) => (precedence?: number) => MapNode&lt;Map&gt; | undefined</div></doc-ct><c-t font="subtitle2">Parameters</c-t><ul><li><code>tableFn: <a href="#s498">ParserTableFn</a>&lt;<a href="#s929">Map</a>, <a href="#s930">ScannerToken</a>&gt;</code></li></ul></doc-card><doc-card id="s172" src="index.ts#L110"><doc-ct><div>text({ source, start, end }: <a href="index--Position.html">Position</a>): string</div></doc-ct><c-t font="subtitle2">Parameters</c-t><ul><li><code>{ source, start, end }: <a href="index--Position.html">Position</a></code></li></ul></doc-card><c-t font="h5">Type Alias</c-t><doc-card id="s32" src="index.ts#L17"><doc-ct><div>BaseNode = <a href="index--Position.html">Position</a> & { children?: <a href="index-api.html#s32">BaseNode</a>[] }</div></doc-ct></doc-card><doc-card id="s103" src="index.ts#L71"><doc-ct><div>DistributeToken&lt;T&gt; = <a href="#s104">T</a> extends <a href="index--Token.html">Token</a>&lt;infer U extends U&gt; ? <a href="index--Token.html">Token</a>&lt;<a href="#s105">U</a>&gt; : never</div></doc-ct></doc-card><doc-card id="s193" src="index.ts#L163"><doc-ct><div>ErrorApi = ReturnType&lt;typeof ErrorApi&gt;</div></doc-ct></doc-card><doc-card id="s91" src="index.ts#L53"><doc-ct><div>InfixNode&lt;Map extends <a href="index-api.html#s35">NodeMap</a>&gt; = <a href="index-api.html#s91">NodeWithChildren</a>&lt;<a href="#s92">Map</a>, [<a href="index-api.html#s52">MapNode</a>&lt;<a href="#s92">Map</a>&gt;, <a href="index-api.html#s52">MapNode</a>&lt;<a href="#s92">Map</a>&gt;]&gt;</div></doc-ct></doc-card><doc-card id="s288" src="index.ts#L262"><doc-ct><div>MakeNodeMap&lt;Base&gt; = { [K in keyof <a href="#s289">Base</a>]: <a href="index--Token.html">Token</a>&lt;<a href="#s290">K</a>&gt; & <a href="#s289">Base</a>[<a href="#s290">K</a>] }</div></doc-ct></doc-card><doc-card id="s100" src="index.ts#L68"><doc-ct><div>MapKind&lt;Map extends <a href="index-api.html#s35">NodeMap</a>&gt; = keyof <a href="#s101">Map</a></div></doc-ct></doc-card><doc-card id="s52" src="index.ts#L70"><doc-ct><div>MapNode&lt;Map extends <a href="index-api.html#s35">NodeMap</a>&gt; = <a href="#s102">Map</a>[keyof <a href="#s102">Map</a>]</div></doc-ct></doc-card><doc-card id="s107" src="index.ts#L74"><doc-ct><div>MapToToken&lt;T extends string&gt; = <a href="#s108">T</a> extends infer U ? <a href="index--Token.html">Token</a>&lt;<a href="#s109">U</a>&gt; : never</div></doc-ct></doc-card><doc-card id="s9" src="index.ts#L10"><doc-ct><div>MatchFn = (ch: string) => boolean</div></doc-ct></doc-card><doc-card id="s35" src="index.ts#L19"><doc-ct><div>NodeMap = { [<div>K: string</div>]: <a href="index--Token.html">Token</a>&lt;string&gt; }</div></doc-ct></doc-card><doc-card id="s45" src="index.ts#L27"><doc-ct><div>Operator&lt;Kind extends keyof <a href="#s47">Map</a>, Map extends <a href="index-api.html#s35">NodeMap</a>&gt; = { <doc-more> precedence: number; infix(node: <a href="index--Token.html">Token</a>&lt;<a href="#s46">Kind</a>&gt;, left: <a href="index-api.html#s52">MapNode</a>&lt;<a href="#s47">Map</a>&gt;): <a href="index-api.html#s52">MapNode</a>&lt;<a href="#s47">Map</a>&gt;; prefix?(node: <a href="index--Token.html">Token</a>&lt;<a href="#s46">Kind</a>&gt;): <a href="index-api.html#s52">MapNode</a>&lt;<a href="#s47">Map</a>&gt;</doc-more> } | { infix?: never; prefix(node: <a href="index--Token.html">Token</a>&lt;<a href="#s46">Kind</a>&gt;): <a href="index-api.html#s52">MapNode</a>&lt;<a href="#s47">Map</a>&gt; }</div></doc-ct></doc-card><doc-card id="s40" src="index.ts#L23"><doc-ct><div>OperatorTable&lt;T extends <a href="index-api.html#s35">NodeMap</a>, Kind extends string&gt; = { [K in <a href="#s42">Kind</a>]: <a href="index-api.html#s45">Operator</a>&lt;<a href="#s43">K</a>, <a href="#s41">T</a>&gt; }</div></doc-ct></doc-card><doc-card id="s83" src="index.ts#L46"><doc-ct><div>ParentNode&lt;Map extends <a href="index-api.html#s35">NodeMap</a>&gt; = <a href="index-api.html#s83">NodeWithChildren</a>&lt;<a href="#s84">Map</a>&gt;</div></doc-ct></doc-card><doc-card id="s292" src="index.ts#L266"><doc-ct><div>ParserApi&lt;Node extends <a href="index--Token.html">Token</a>&lt;string&gt;&gt; = <a href="#s508">ReturnType</a>&lt;typeof ParserApi&gt;</div></doc-ct></doc-card><doc-card id="s14" src="index.ts#L12"><doc-ct><div>ScanFn&lt;Node extends <a href="index--Token.html">Token</a>&lt;string&gt;&gt; = () => <a href="#s15">Node</a></div></doc-ct></doc-card><doc-card id="s18" src="index.ts#L13"><doc-ct><div>Scanner&lt;Node extends <a href="index--Token.html">Token</a>&lt;string&gt;&gt; = (src: string) => { next: <a href="index-api.html#s14">ScanFn</a>&lt;<a href="#s19">Node</a>&gt;; backtrack: (pos: <a href="index--Position.html">Position</a>) => void }</div></doc-ct></doc-card><doc-card id="s225" src="index.ts#L203"><doc-ct><div>SymbolTable&lt;S extends { name: string }&gt; = ReturnType&lt;typeof SymbolTable&gt;</div></doc-ct></doc-card><doc-card id="s95" src="index.ts#L57"><doc-ct><div>TernaryNode&lt;Map extends <a href="index-api.html#s35">NodeMap</a>, Optional extends boolean&gt; = <a href="index-api.html#s95">NodeWithChildren</a>&lt;<a href="#s96">Map</a>, [<a href="index-api.html#s52">MapNode</a>&lt;<a href="#s96">Map</a>&gt;, <a href="index-api.html#s52">MapNode</a>&lt;<a href="#s96">Map</a>&gt;, <a href="#s97">Optional</a> extends true ? <a href="index-api.html#s52">MapNode</a>&lt;<a href="#s96">Map</a>&gt; | undefined : <a href="index-api.html#s52">MapNode</a>&lt;<a href="#s96">Map</a>&gt;]&gt;</div></doc-ct></doc-card><doc-card id="s111" src="index.ts#L75"><doc-ct><div>TrieNode = { [K in string]: <a href="index-api.html#s111">TrieNode</a> } & { [TrieMatch]?: string }</div></doc-ct></doc-card><doc-card id="s87" src="index.ts#L48"><doc-ct><div>UnaryNode&lt;Map extends <a href="index-api.html#s35">NodeMap</a>&gt; = <a href="index-api.html#s87">NodeWithChildren</a>&lt;<a href="#s88">Map</a>, [<a href="index-api.html#s52">MapNode</a>&lt;<a href="#s88">Map</a>&gt;]&gt;</div></doc-ct></doc-card></c-body></c-application>