{"index":[{"id":32,"name":"BaseNode","kind":2,"flags":1,"type":"Position & { children?: BaseNode[] }","resolvedType":"Position & { children?: BaseNode[] | undefined }","tsconfig":"tsconfig.json"},{"id":168,"name":"CompilerError","kind":8,"flags":1,"children":[{"id":169,"name":"constructor","parameters":[{"id":170,"name":"message","kind":10,"flags":4,"type":"string"},{"id":171,"name":"position","kind":10,"flags":4,"type":1}],"kind":14,"type":168},{"id":170,"name":"message","kind":10,"flags":4,"type":"string"},{"id":171,"name":"position","kind":10,"flags":4,"type":1}],"tsconfig":"tsconfig.json"},{"id":103,"name":"DistributeToken","kind":2,"flags":1,"type":"T extends Token<infer U extends U> ? Token<U> : never","typeP":[{"id":104,"name":"T","kind":3,"type":"T"}],"tsconfig":"tsconfig.json"},{"id":193,"name":"ErrorApi","kind":2,"flags":1,"type":{"name":"ReturnType","kind":34},"resolvedType":{"kind":34},"tsconfig":"tsconfig.json"},{"id":91,"name":"InfixNode","kind":2,"flags":1,"type":91,"typeP":[{"id":92,"name":"Map","kind":3,"type":"Map extends NodeMap"}],"resolvedType":"{ [K in keyof Map]: Map[K] extends { children: [MapNode, MapNode] } ? Map[K] : never }[keyof Map]","tsconfig":"tsconfig.json"},{"id":288,"name":"MakeNodeMap","kind":2,"flags":1,"type":"{ [K in keyof Base]: Token & Base[K] }","typeP":[{"id":289,"name":"Base","kind":3,"type":"Base"}],"tsconfig":"tsconfig.json"},{"id":100,"name":"MapKind","kind":2,"flags":1,"type":"keyof Map","typeP":[{"id":101,"name":"Map","kind":3,"type":"Map extends NodeMap"}],"tsconfig":"tsconfig.json"},{"id":52,"name":"MapNode","kind":2,"flags":1,"type":"Map[keyof Map]","typeP":[{"id":102,"name":"Map","kind":3,"type":"Map extends NodeMap"}],"tsconfig":"tsconfig.json"},{"id":107,"name":"MapToToken","kind":2,"flags":1,"type":"T extends infer U ? Token<U> : never","typeP":[{"id":108,"name":"T","kind":3,"type":"T extends string"}],"tsconfig":"tsconfig.json"},{"id":9,"name":"MatchFn","kind":2,"flags":1,"type":{"id":10,"parameters":[{"id":11,"name":"ch","kind":9,"type":"string"}],"kind":17},"resolvedType":{"id":12,"parameters":[{"id":13,"name":"ch","kind":9,"type":"string"}],"kind":17},"tsconfig":"tsconfig.json"},{"id":35,"name":"NodeMap","kind":2,"flags":1,"type":{"kind":34},"resolvedType":{"kind":34},"tsconfig":"tsconfig.json"},{"id":76,"name":"NodeWithChildren","kind":2,"type":"{ [K in keyof Map]: Map[K] extends { children: Children } ? Map[K] : never }[keyof Map]","typeP":[{"id":77,"name":"Map","kind":3,"type":"Map extends NodeMap"},{"id":78,"name":"Children","kind":3,"type":"Children"}]},{"id":45,"name":"Operator","kind":2,"flags":1,"type":{"kind":5},"typeP":[{"id":46,"name":"Kind","kind":3,"type":"Kind extends keyof Map"},{"id":47,"name":"Map","kind":3,"type":"Map extends NodeMap"}],"resolvedType":{"kind":5},"tsconfig":"tsconfig.json"},{"id":40,"name":"OperatorTable","kind":2,"flags":1,"type":"{ [K in Kind extends string]: Operator }","typeP":[{"id":41,"name":"T","kind":3,"type":"T extends NodeMap"},{"id":42,"name":"Kind","kind":3,"type":"Kind extends string"}],"resolvedType":"{ [K in Kind]: [object Object] }","tsconfig":"tsconfig.json"},{"id":83,"name":"ParentNode","kind":2,"flags":1,"type":83,"typeP":[{"id":84,"name":"Map","kind":3,"type":"Map extends NodeMap"}],"resolvedType":"{ [K in keyof Map]: Map[K] extends { children: MapNode[] } ? Map[K] : never }[keyof Map]","tsconfig":"tsconfig.json"},{"id":505,"name":"ParseTableApi","kind":2,"type":"ParserApi<ScannerToken> & ReturnType<typeof parseTableApi>","typeP":[{"id":506,"name":"Map","kind":3,"type":"Map extends NodeMap"},{"id":507,"name":"ScannerToken","kind":3,"type":"ScannerToken extends Token<string>"}],"resolvedType":"{ current: () => ScannerToken; error: (msg: string, pos: Position) => CompilerError; pushError: (error: CompilerError) => void; errors: CompilerError[]; expect: <K extends ScannerToken[\"kind\"]>(kind: K) => Token<K>; expectNode: <C>(node: C | undefined, msg: string) => NonNullable<C>; expectNodeKind: <N extends Token<string>, K extends N[\"kind\"]>(node: N | undefined, kind: K, msg: string) => Extract<N, { kind: K }>; expectNodeParser: (fn: () => ScannerToken | undefined, msg: string) => () => NonNullable<ScannerToken>; next: () => ScannerToken; node: <K extends string>(kind: K) => Token<K>; optional: <K extends ScannerToken[\"kind\"]>(kind: K) => Token<K> | undefined; skipWhile: (kind: ScannerToken[\"kind\"]) => void; enclosed: <C extends ScannerToken>(start: ScannerToken[\"kind\"], content: () => C, end: ScannerToken[\"kind\"]) => C; skipUntil: (condition: () => boolean) => void; parseUntil: <C>(parser: () => C | undefined, condition: () => boolean) => C[]; parseUntilKind: <C>(parser: () => C | undefined, kind: ScannerToken[\"kind\"]) => C[]; parseList: <C>(parseFn: () => C | undefined, separator: ScannerToken[\"kind\"], isItem: (item: C) => boolean) => C[]; parseListWithEmpty: <C>(parseFn: () => C | undefined, separator: ScannerToken[\"kind\"], isItem: (item: C) => boolean) => (C | undefined)[]; start: (src: string) => void; backtrack: (pos: ScannerToken) => void; parseWhile: <C>(parser: () => C | undefined) => C[] } & { expression: (precedence?: number) => MapNode<Map> | undefined; expectExpression: (precedence?: number) => NonNullable<MapNode<Map>>; infix: <Node extends InfixNode<Map>>(rbp: number, cb?: ((node: Node) => void) | undefined) => (tk: Token<string>, left: MapNode<Map>) => Node; infixOperator: <Node extends InfixNode<Map>>(precedence: number, rightBindingPower?: number, cb?: ((node: Node) => void) | undefined) => { precedence: number; infix: (tk: Token<string>, left: MapNode<Map>) => Node }; ternary: <Node extends TernaryNode<Map, false>>(precedence: number, operator2: ScannerToken[\"kind\"]) => (node: Token<Node[\"kind\"]>, left: MapNode<Map>) => Node; ternaryOptional: <Node extends TernaryNode<Map, true>>(precedence: number, operator2: ScannerToken[\"kind\"]) => (node: Token<Node[\"kind\"]>, left: MapNode<Map>) => Node; prefix: <K extends UnaryNode<Map>[\"kind\"]>(rbp?: number, cb?: ((node: UnaryNode<Map>) => MapNode<Map>) | undefined) => (tk: Token<K>) => MapNode<Map>; current: () => ScannerToken; error: (msg: string, pos: Position) => CompilerError; pushError: (error: CompilerError) => void; errors: CompilerError[]; expect: <K extends ScannerToken[\"kind\"]>(kind: K) => Token<K>; expectNode: <C>(node: C | undefined, msg: string) => NonNullable<C>; expectNodeKind: <N extends Token<string>, K extends N[\"kind\"]>(node: N | undefined, kind: K, msg: string) => Extract<N, { kind: K }>; expectNodeParser: (fn: () => ScannerToken | undefined, msg: string) => () => NonNullable<ScannerToken>; next: () => ScannerToken; node: <K extends string>(kind: K) => Token<K>; optional: <K extends ScannerToken[\"kind\"]>(kind: K) => Token<K> | undefined; skipWhile: (kind: ScannerToken[\"kind\"]) => void; enclosed: <C extends ScannerToken>(start: ScannerToken[\"kind\"], content: () => C, end: ScannerToken[\"kind\"]) => C; skipUntil: (condition: () => boolean) => void; parseUntil: <C>(parser: () => C | undefined, condition: () => boolean) => C[]; parseUntilKind: <C>(parser: () => C | undefined, kind: ScannerToken[\"kind\"]) => C[]; parseList: <C>(parseFn: () => C | undefined, separator: ScannerToken[\"kind\"], isItem: (item: C) => boolean) => C[]; parseListWithEmpty: <C>(parseFn: () => C | undefined, separator: ScannerToken[\"kind\"], isItem: (item: C) => boolean) => (C | undefined)[]; start: (src: string) => void; backtrack: (pos: ScannerToken) => void; parseWhile: <C>(parser: () => C | undefined) => C[] }"},{"id":292,"name":"ParserApi","kind":2,"flags":1,"type":{"id":508,"name":"ReturnType","kind":34},"typeP":[{"id":293,"name":"Node","kind":3,"type":"Node extends Token<string>"}],"resolvedType":{"kind":34},"tsconfig":"tsconfig.json"},{"id":498,"name":"ParserTableFn","kind":2,"type":{"id":501,"parameters":[{"id":502,"name":"tableApi","kind":9,"type":"ParseTableApi"}],"kind":17},"typeP":[{"id":499,"name":"Map","kind":3,"type":"Map extends NodeMap"},{"id":500,"name":"ScannerToken","kind":3,"type":"ScannerToken extends Token<string>"}],"resolvedType":{"id":503,"parameters":[{"id":504,"name":"tableApi","kind":9,"type":"ParseTableApi<Map, ScannerToken>"}],"kind":17}},{"id":1,"name":"Position","kind":4,"flags":1,"children":[{"id":3,"name":"end","kind":10,"flags":4,"type":"number"},{"id":4,"name":"line","kind":10,"flags":4,"type":"number"},{"id":5,"name":"source","kind":10,"flags":4,"type":"string"},{"id":2,"name":"start","kind":10,"flags":4,"type":"number"}],"tsconfig":"tsconfig.json"},{"id":14,"name":"ScanFn","kind":2,"flags":1,"type":{"id":16,"kind":17},"typeP":[{"id":15,"name":"Node","kind":3,"type":"Node extends Token<string>"}],"resolvedType":{"id":17,"kind":17},"tsconfig":"tsconfig.json"},{"id":18,"name":"Scanner","kind":2,"flags":1,"type":{"id":20,"parameters":[{"id":25,"name":"src","kind":9,"type":"string"}],"kind":17},"typeP":[{"id":19,"name":"Node","kind":3,"type":"Node extends Token<string>"}],"resolvedType":{"id":26,"parameters":[{"id":31,"name":"src","kind":9,"type":"string"}],"kind":17},"tsconfig":"tsconfig.json"},{"id":225,"name":"SymbolTable","kind":2,"flags":1,"type":{"name":"ReturnType","kind":34},"typeP":[{"id":226,"name":"S","kind":3,"type":"S extends { name: string }"}],"resolvedType":{"kind":34},"tsconfig":"tsconfig.json"},{"id":95,"name":"TernaryNode","kind":2,"flags":1,"type":95,"typeP":[{"id":96,"name":"Map","kind":3,"type":"Map extends NodeMap"},{"id":97,"name":"Optional","kind":3,"type":"Optional extends boolean"}],"resolvedType":"{ [K in keyof Map]: Map[K] extends { children: [MapNode, MapNode, Optional extends true ? MapNode | undefined : MapNode] } ? Map[K] : never }[keyof Map]","tsconfig":"tsconfig.json"},{"id":6,"name":"Token","kind":4,"flags":1,"type":{"kind":33,"children":[{"kind":6,"type":1}],"type":6},"typeP":[{"id":7,"name":"Kind","kind":3,"type":"Kind"}],"children":[{"id":8,"name":"kind","kind":10,"flags":4,"type":"Kind"}],"tsconfig":"tsconfig.json"},{"id":111,"name":"TrieNode","kind":2,"flags":1,"type":"{ [K in string]: TrieNode } & { [TrieMatch]?: string }","resolvedType":"{ [x: string]: TrieNode } & { ? => string | undefined }","tsconfig":"tsconfig.json"},{"id":87,"name":"UnaryNode","kind":2,"flags":1,"type":87,"typeP":[{"id":88,"name":"Map","kind":3,"type":"Map extends NodeMap"}],"resolvedType":"{ [K in keyof Map]: Map[K] extends { children: [MapNode] } ? Map[K] : never }[keyof Map]","tsconfig":"tsconfig.json"}]}